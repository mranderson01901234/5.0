/**
 * Migration script to backfill embeddings for existing memories
 * Queues all memories without embeddings for background processing
 */

import { createDatabase } from '../apps/memory-service/src/db.js';
import { getMemoriesWithoutEmbeddings, addToEmbeddingQueue } from '../apps/memory-service/src/embedding-service.js';
import { pino } from 'pino';

const logger = pino({ name: 'migrate-embeddings' });

const DB_PATH = process.env.DB_PATH || './data/memory.db';
const BATCH_SIZE = parseInt(process.env.MIGRATION_BATCH_SIZE || '50', 10);

async function migrateExistingMemories(): Promise<void> {
  if (!process.env.OPENAI_API_KEY) {
    logger.error('OPENAI_API_KEY not set. Cannot migrate embeddings.');
    process.exit(1);
  }

  logger.info({ dbPath: DB_PATH, batchSize: BATCH_SIZE }, 'Starting embedding migration');

  const db = createDatabase(DB_PATH);
  let offset = 0;
  let totalQueued = 0;

  try {
    while (true) {
      const memories = getMemoriesWithoutEmbeddings(db, BATCH_SIZE, offset);

      if (memories.length === 0) {
        logger.info({ totalQueued }, 'No more memories to queue. Migration complete.');
        break;
      }

      // Queue each memory for embedding generation
      for (const memory of memories) {
        try {
          await addToEmbeddingQueue(db, memory.id, memory.content);
          totalQueued++;
        } catch (error: any) {
          logger.warn({ memoryId: memory.id, error: error.message }, 'Failed to queue memory for embedding');
        }
      }

      logger.info({ 
        offset, 
        queued: memories.length, 
        totalQueued,
        progress: `${((offset + memories.length) / Math.max(offset + memories.length, 1)) * 100}%`
      }, 'Queued batch for embedding generation');

      offset += BATCH_SIZE;

      // Small delay to avoid overwhelming the system
      await new Promise(resolve => setTimeout(resolve, 100));
    }

    logger.info({ 
      totalQueued,
      message: 'Migration complete. Embeddings will be generated by the background worker.'
    }, 'Embedding migration finished');
  } catch (error: any) {
    logger.error({ error: error.message }, 'Migration failed');
    process.exit(1);
  } finally {
    db.close();
  }
}

// Run migration
migrateExistingMemories().catch((error) => {
  logger.error({ error }, 'Migration script failed');
  process.exit(1);
});

